CompilationUnit = (WS PackageDeclaration)? (WS ImportDeclaration)* (WS TypeDeclaration)* WS
PackageDeclaration = (PackageModifiers WS)? "package"&Tk WS Identifier (WS '.' WS Identifier)* WS ';'
PackageModifiers = PackageModifier (WS PackageModifier)*
PackageModifier = Annotation

ImportDeclaration = SingleTypeImportDeclaration

SingleTypeImportDeclaration = "import"&Tk WS TypeName WS ';'


TypeDeclaration = ClassDeclaration
  | InterfaceDeclaration
  | ';'

TypeName = Identifier
  | PackageOrTypeName '.' Identifier
PackageOrTypeName = Identifier
  | PackageOrTypeName '.' Identifier

NumericType = IntegralType
  | FloatingPointType
IntegralType = ("byte" | "short" | "int" | "long" | "char")&Tk
FloatingPointType = ("float" | "double")&Tk


PrimitiveType = (Annotations WS)? NumericType
  | (Annotations WS)? "boolean"&Tk


Block = '{' (WS BlockStatements)? WS '}' {Block(stmts=$1 ?: [])}
BlockStatements = BlockStatement (WS BlockStatement)* {[$0] + $1}
BlockStatement = LocalVariableDeclarationStatement
  | ClassDeclaration
  | Statement
LocalVariableDeclarationStatement = LocalVariableDeclaration WS ';'
LocalVariableDeclaration = (VariableModifiers WS)? UnannType WS VariableDeclaratorList {LocalVariableDeclaration(modifiers=$0 ?: [], typ=$1, decls=$3)}
VariableModifiers = VariableModifier (WS VariableModifier)* {[$0] + $1}
VariableModifier = Annotation | "final"&Tk
VariableDeclaratorList = VariableDeclarator (WS ',' WS VariableDeclarator)* {[$0] + $1}
VariableDeclarator = VariableDeclaratorId (WS '=' WS VariableInitializer)? {(VariableDeclarator(id=$0, init=$1))}
VariableDeclaratorId = Identifier (WS Dims)* {VariableDeclaratorId(name=$0, dims=$1)}
Dim = (Annotation (WS Annotation)* WS)? '[' WS ']' {Dim(annots=$0{[$0] + $1})}
Dims = Dim (WS Dim)* {[$0] + $1}
VariableInitializer = Expression | ArrayInitializer


Annotations = Annotation (WS Annotation)*

Statement = StatementWithoutTrailingSubstatement
  | LabeledStatement
  | IfThenStatement
  | IfThenElseStatement
  | WhileStatement
  | ForStatement

StatementWithoutTrailingSubstatement = Block
  | EmptyStatement
  | ExpressionStatement
  | BreakStatement
  | ContinueStatement
  | ReturnStatement
  | ThrowStatement
  | TryStatement

EmptyStatement = ';' {EmptyStatement()}

LabeledStatement = Identifier WS ':' WS Statement {LabeledStatement(label=$0, stmt=$4)}

ExpressionStatement = StatementExpression WS ';' $0
StatementExpression = Assignment
  | MethodInvocation
  | ClassInstanceCreationExpression

IfThenStatement = "if"&Tk WS '(' WS Expression WS ')' WS Statement {IfThenStatement(condition=$4, thenbody=$8)}
IfThenElseStatement = "if"&Tk WS '(' WS Expression WS ')' WS Statement WS "else"&Tk WS Statement {IfThenElseStatement(condition=$4, thenbody=$8, elsebody=$12)}

IfStatement = <IfThenStatement | IfThenElseStatement>

WhileStatement = "while"&Tk WS '(' WS Expression WS ')' WS Statement {WhileStatement(condition=$4, body=$8)}



ForStatement = BasicForStatement
BasicForStatement = "for"&Tk WS '(' WS ForInit WS ';' WS Expression WS ';' WS ForUpdate WS ')' WS Statement
                    {BasicForStatement(init=$4, condition=$8, update=$12, body=$16)}
ForInit = StatementExpressionList | LocalVariableDeclaration
ForUpdate = StatementExpressionList
StatementExpressionList = StatementExpression (WS ',' WS StatementExpression)* {[$0] + $1}

BreakStatement = "break"&Tk (WS Identifier)? WS ';' {BreakStatement(label=$1)}
ContinueStatement = "continue"&Tk (WS Identifier)? WS ';' {ContinueStatement(label=$1)}

ReturnStatement = "return"&Tk (WS Expression)? WS ';' {ReturnStatement(value=$1)}
ThrowStatement = "throw"&Tk (WS Expression)? WS ';' {ThrowStatement(exception=$1)}

TryStatement = "try"&Tk WS Block WS Catches {TryStatement(block=$2, catches=$4, finally=null)}
  | "try"&Tk WS Block (WS Catches)? WS Finally {TryStatement(block=$2, catches=$3, finally=$5)}
Catches = CatchClause (WS CatchClause)* {[$0] + $1}
CatchClause = "catch"&Tk WS '(' WS CatchFormalParameter WS ')' WS Block {CatchClause(catchingType=$4, handler=$8)}
CatchFormalParameter = (VariableModifiers WS)? CatchType WS VariableDeclaratorId
CatchType = UnannClassType (WS '|' WS ClassType)* {CatchType(typ=[$0] + $1)}
Finally = "finally"&Tk WS Block {FinallyBlock(body=$2)}




Expression = LambdaExpression
  | AssignmentExpression



AssignmentExpression = ConditionalExpression
  | Assignment
Assignment = LeftHandSide WS AssignmentOperator WS Expression
LeftHandSide = ExpressionName
  | FieldAccess
  | ArrayAccess
AssignmentOperator =
  ("=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=")&Tk


ConditionalExpression = ConditionalOrExpression
  | ConditionalOrExpression WS '?'&Tk WS Expression WS ':' WS ConditionalExpression
  | ConditionalOrExpression WS '?'&Tk WS Expression WS ':' WS LambdaExpression

ConditionalOrExpression = ConditionalAndExpression
  | ConditionalOrExpression WS "||"&Tk WS ConditionalAndExpression


ConditionalAndExpression = InclusiveOrExpression
  | ConditionalAndExpression WS "&&"&Tk WS InclusiveOrExpression


InclusiveOrExpression = ExclusiveOrExpression
  | InclusiveOrExpression WS "|"&Tk WS ExclusiveOrExpression
ExclusiveOrExpression = AndExpression
  | ExclusiveOrExpression WS "^"&Tk WS AndExpression
AndExpression = EqualityExpression
  | AndExpression WS "&"&Tk WS EqualityExpression
EqualityExpression = RelationalExpression
  | EqualityExpression WS "=="&Tk WS RelationalExpression
  | EqualityExpression WS "!="&Tk WS RelationalExpression
RelationalExpression = ShiftExpression
  | RelationalExpression WS "<"&Tk WS ShiftExpression
  | RelationalExpression WS ">"&Tk WS ShiftExpression
  | RelationalExpression WS "<="&Tk WS ShiftExpression
  | RelationalExpression WS ">="&Tk WS ShiftExpression
  | RelationalExpression WS "instanceof"&Tk WS ReferenceType
ShiftExpression = AdditiveExpression
  | ShiftExpression WS "<<"&Tk WS AdditiveExpression
  | ShiftExpression WS ">>"&Tk WS AdditiveExpression
  | ShiftExpression WS ">>>"&Tk WS AdditiveExpression
AdditiveExpression = MultiplicativeExpression
  | AdditiveExpression WS "+"&Tk WS MultiplicativeExpression
  | AdditiveExpression WS "-"&Tk WS MultiplicativeExpression
MultiplicativeExpression = UnaryExpression
  | MultiplicativeExpression WS "*"&Tk WS UnaryExpression
  | MultiplicativeExpression WS "/"&Tk WS UnaryExpression
  | MultiplicativeExpression WS "%"&Tk WS UnaryExpression
UnaryExpression = PreIncrementExpression
  | PreDecrementExpression
  | "+"&Tk UnaryExpression
  | "-"&Tk UnaryExpression
  | UnaryExpressionNotPlusMinus
PreIncrementExpression = "++"&Tk WS UnaryExpression
PreDecrementExpression = "--"&Tk WS UnaryExpression
UnaryExpressionNotPlusMinus = PostfixExpression
  | "~"&Tk WS UnaryExpression
  | "!"&Tk WS UnaryExpression
  | CastExpression
CastExpression = '(' WS PrimitiveType WS ')' WS UnaryExpression
  | '(' WS ReferenceType (WS AdditionalBound)* WS ')' WS UnaryExpressionNotPlusMinus
  | '(' WS ReferenceType (WS AdditionalBound)* WS ')' WS LambdaExpression
PostfixExpression = Primary
  | ExpressionName
  | PostIncrementExpression
  | PostDecrementExpression
PostIncrementExpression = PostfixExpression WS "++"&Tk
PostDecrementExpression = PostfixExpression WS "--"&Tk



Primary = PrimaryNoNewArray
  | ArrayCreationExpression
PrimaryNoNewArray = Literal
  | ClassLiteral
  | "this"&Tk
  | TypeName WS '.' WS "this"&Tk
  | '(' WS Expression WS ')'
  | ClassInstanceCreationExpression
  | FieldAccess
  | ArrayAccess
  | MethodInvocation
  | MethodReference
ClassLiteral = TypeName (WS '[' WS ']')* WS "."&Tk WS "class"&Tk
  | NumericType (WS '[' WS ']')* WS "."&Tk WS "class"&Tk
  | "boolean"&Tk (WS '[' WS ']')* WS "."&Tk WS "class"&Tk
  | "void"&Tk WS "."&Tk WS "class"&Tk





ClassInstanceCreationExpression = UnqualifiedClassInstanceCreationExpression
  | ExpressionName WS "."&Tk WS UnqualifiedClassInstanceCreationExpression
  | Primary WS "."&Tk WS UnqualifiedClassInstanceCreationExpression
UnqualifiedClassInstanceCreationExpression = "new"&Tk WS TypeArguments? WS ClassOrInterfaceTypeToInstantiate WS '(' WS ArgumentList? WS ')' (WS ClassBody)?
ClassOrInterfaceTypeToInstantiate = (Annotations WS)? Identifier (WS '.' (WS Annotations)? WS Identifier)*
 (WS TypeArgumentsOrDiamond)?
TypeArgumentsOrDiamond = TypeArguments
  | '<' WS '>'
TypeArguments = '<' WS TypeArgumentList WS '>'
TypeArgumentList = TypeArgument (WS ',' WS TypeArgument)*
TypeArgument = ReferenceType | Wildcard
Wildcard = (Annotations WS)? '?' (WS WildcardBounds)?
WildcardBounds = "extends"&Tk WS ReferenceType
  | "super"&Tk WS ReferenceType





MethodInvocation = MethodName WS '(' (WS ArgumentList)? WS ')'
  | TypeName WS '.' (WS TypeArguments)? WS Identifier WS '(' (WS ArgumentList)? WS ')'
  | ExpressionName WS '.' (WS TypeArguments)? WS Identifier WS '(' (WS ArgumentList)? WS ')'
  | Primary WS '.' (WS TypeArguments)? WS Identifier WS '(' (WS ArgumentList)? WS ')'
  | "super"&Tk WS '.' (WS TypeArguments)? WS Identifier WS '(' (WS ArgumentList)? WS ')'
  | TypeName WS '.' WS "super"&Tk WS '.' (WS TypeArguments)? WS Identifier WS '(' (WS ArgumentList)? WS ')'
ArgumentList = Expression (WS ',' WS Expression)*




MethodReference = ExpressionName WS "::"&Tk (WS TypeArguments)? WS Identifier
  | ReferenceType WS "::"&Tk (WS TypeArguments)? WS Identifier
  | Primary WS "::"&Tk (WS TypeArguments)? WS Identifier
  | "super"&Tk WS "::"&Tk (WS TypeArguments)? WS Identifier
  | TypeName WS '.' WS "super"&Tk WS "::"&Tk (WS TypeArguments)? WS Identifier
  | ClassType WS "::"&Tk (WS TypeArguments)? WS "new"&Tk
  | ArrayType WS "::"&Tk WS "new"&Tk




MethodDeclaration = (MethodModifiers WS)? MethodHeader WS MethodBody
MethodModifiers = MethodModifier (WS MethodModifier)*
MethodModifier = Annotation
  | ("public" | "protected" | "private" | "abstract" | "static" | "final")&Tk
MethodHeader = Result WS MethodDeclarator (WS Throws)? TypeParameters (WS Annotations)? WS Result WS MethodDeclarator (WS Throws)?
MethodDeclarator = Identifier WS '(' (WS FormalParameterList)? WS ')' Dims?
Result = UnannType | "void"&Tk
Throws = "throws"&Tk WS ExceptionTypeList
ExceptionTypeList = ExceptionType (WS ',' WS ExceptionType)*
ExceptionType = ClassType | TypeVariable
MethodBody = Block | ';'
TypeParameters = '<' WS TypeParameter (WS ',' WS TypeParameter)* WS '>'




ClassDeclaration = NormalClassDeclaration
  | EnumDeclaration
NormalClassDeclaration = (ClassModifiers WS)? WS "class"&Tk WS Identifier (WS TypeParameters)? (WS Superclass)? (WS Superinterfaces)? WS ClassBody
ClassModifiers = ClassModifier (WS ClassModifier)*
ClassModifier = Annotation
  | ("public" | "protected" | "private" | "abstract" | "static" | "final")&Tk
Superclass = "extends"&Tk WS ClassType
Superinterfaces = "implements"&Tk WS InterfaceTypeList
InterfaceTypeList = InterfaceType (WS ',' WS InterfaceType)*
ClassBody = '{' (WS ClassBodyDeclaration)* WS '}'
ClassBodyDeclaration = ClassMemberDeclaration
  | InstanceInitializer
  | StaticInitializer
  | ConstructorDeclaration
ClassMemberDeclaration = FieldDeclaration
  | MethodDeclaration
  | ClassDeclaration
  | InterfaceDeclaration
  | ';'


EnumDeclaration = (ClassModifiers WS)? "enum"&Tk WS Identifier (WS Superinterfaces)? WS EnumBody
EnumBody = '{' (WS EnumConstantList)? (WS ',')? (WS EnumBodyDeclarations)? WS '}'
EnumConstantList = EnumConstant (WS ',' WS EnumConstant)*
EnumConstant = (EnumConstantModifiers WS)? Identifier ('(' (WS ArgumentList)? WS ')')? (WS ClassBody)?
EnumConstantModifiers = EnumConstantModifier (WS EnumConstantModifiers)*
EnumConstantModifier = Annotation
EnumBodyDeclarations = ';' (WS ClassBodyDeclaration)*


InstanceInitializer = Block
StaticInitializer = "static"&Tk WS Block
ConstructorDeclaration = (ConstructorModifier WS)? ConstructorDeclarator (WS Throws)? WS ConstructorBody
ConstructorDeclarator = (TypeParameters WS)? SimpleTypeName '(' (WS FormalParameterList)? WS ')'
SimpleTypeName = Identifier
ConstructorModifier = Annotation | ("public" | "protected" | "private")&Tk
ConstructorBody = '{' (WS ExplicitConstructorInvocation)? (WS BlockStatements)? WS '}'
ExplicitConstructorInvocation = (TypeArguments WS)? "this"&Tk WS '(' (WS ArgumentList)? WS ')' WS ';'
  | (TypeArguments WS)? "super"&Tk WS '(' (WS ArgumentList)? WS ')' WS ';'
  | ExpressionName WS '.' (WS TypeArguments)? WS "super"&Tk WS '(' (WS ArgumentList)? WS ')' WS ';'
  | Primary WS '.' (WS TypeArguments)? WS "super"&Tk WS '(' (WS ArgumentList)? WS ')' WS ';'



FieldDeclaration = (FieldModifiers WS)? UnannType WS VariableDeclaratorList
FieldModifiers = FieldModifier (WS FieldModifier)*
FieldModifier = Annotation
  | ("public" | "protected" | "private" | "static" | "final")&Tk


InterfaceDeclaration = NormalInterfaceDeclaration
  | AnnotationTypeDeclaration
NormalInterfaceDeclaration = (InterfaceModifiers WS)? "interface"&Tk WS Identifier (WS TypeParameters)?
 (WS ExtendsInterfaces)? WS InterfaceBody
InterfaceModifiers = InterfaceModifier (WS InterfaceModifier)*
InterfaceModifier = Annotation
  | ("public" | "protected" | "private" | "abstract" | "static")&Tk
ExtendsInterfaces = "extends"&Tk WS InterfaceTypeList
InterfaceBody = '{' (WS InterfaceMemberDeclaration)* WS '}'
InterfaceMemberDeclaration = ConstantDeclaration
  | InterfaceMethodDeclaration
  | ClassDeclaration
  | InterfaceDeclaration
  | ';'
InterfaceMethodDeclaration = (InterfaceMethodModifiers WS)? MethodHeader WS MethodBody
InterfaceMethodModifiers = InterfaceMethodModifier (WS InterfaceMethodModifier)*
InterfaceMethodModifier = Annotation
  | ("public" | "abstract" | "default" | "static")&Tk


AnnotationTypeDeclaration = (InterfaceModifiers WS)? '@' WS "interface"&Tk WS Identifier WS AnnotationTypeBody

AnnotationTypeBody = '{' (WS AnnotationTypeMemberDeclaration)* WS '}'
AnnotationTypeMemberDeclaration = AnnotationTypeElementDeclaration
  | ConstantDeclaration
  | ClassDeclaration
  | InterfaceDeclaration
  | ';'
AnnotationTypeElementDeclaration = (AnnotationTypeElementModifier WS)? UnannType WS Identifier WS '(' WS ')' (WS Dims)? (WS DefaultValue)? WS ';'
AnnotationTypeElementModifier = Annotation | ("public" | "abstract")&Tk
DefaultValue = "default"&Tk WS ElementValue


ConstantDeclaration = (ConstantModifiers WS)? UnannType WS VariableDeclaratorList WS ';'
ConstantModifiers = ConstantModifier (WS ConstantModifier)*
ConstantModifier = Annotation
  | ("public" | "static" | "final")&Tk
FormalParameterList = FormalParameters WS ',' WS LastFormalParameter
  | LastFormalParameter
FormalParameters = FormalParameters (WS ',' WS FormalParameter)?
FormalParameter = (VariableModifiers WS)? UnannType WS VariableDeclaratorId
LastFormalParameter = (VariableModifiers WS)? UnannType (WS Annotations)? WS "..."&Tk WS VariableDeclaratorId WS FormalParameter





Annotation = NormalAnnotation
  | MarkerAnnotation
  | SingleElementAnnotation
NormalAnnotation = '@' WS TypeName WS '(' (WS ElementValuePairList)? WS ')'
ElementValuePairList = ElementValuePair (WS ',' WS ElementValuePair)*
ElementValuePair = Identifier WS '=' WS ElementValue
ElementValue = ConditionalExpression
  | ElementValueArrayInitializer
  | Annotation
ElementValueArrayInitializer = '{' (WS ElementValueList)? (WS ',')? WS '}'
ElementValueList = ElementValue (WS ',' WS ElementValue)*

MarkerAnnotation = '@' WS TypeName
SingleElementAnnotation = '@' WS TypeName WS '(' WS ElementValue WS ')'





UnannType = UnannPrimitiveType
  | UnannReferenceType
UnannPrimitiveType = NumericType
  | "boolean"&Tk
UnannReferenceType = UnannClassOrInterfaceType
  | UnannTypeVariable
  | UnannArrayType
UnannClassOrInterfaceType = UnannClassType
  | UnannInterfaceType
UnannClassType = Identifier (WS TypeArguments)?
  | UnannClassOrInterfaceType WS '.' (WS Annotations)? WS Identifier (WS TypeArguments)?
UnannInterfaceType = UnannClassType
UnannTypeVariable = Identifier
UnannArrayType = UnannPrimitiveType WS Dims
  | UnannClassOrInterfaceType WS Dims
  | UnannTypeVariable WS Dims


WS = ' \t\u000c' | LineTerminator | Comment
LineTerminator = <'\n\r' | "\n\r">
Comment = BlockComment | LineComment
BlockComment = "/*" ((. !"*/")* .)? "*/"
LineComment = "//" (.-'\n')* (EOF | '\n')
EOF = !.

Tk = Token
Token = Identifier | Keyword | Literal | Separator | Operator
Word = <'a-zA-Z0-9_'+>
Identifier = Word-(Keyword | BooleanLiteral | NullLiteral)
Keyword = ("abstract" | "continue" | "for" | "new" | "switch" | "assert" | "default" | "if" | "package" | "synchronized" | "boolean" | "do" | "goto" | "private" | "this" | "break" | "double" | "implements" | "protected" | "throw" | "byte" | "else" | "import" | "public" | "throws" | "case" | "enum" | "instanceof" | "return" | "transient" | "catch" | "extends" | "int" | "short" | "try" | "char" | "final" | "interface" | "static" | "void" | "class" | "finally" | "long" | "strictfp" | "volatile" | "const" | "float" | "native" | "super" | "while")&Word

BooleanLiteral = <"true" | "false">

NullLiteral = <"null">

Literal = IntegerLiteral
  | FloatingPointLiteral
  | BooleanLiteral
  | CharacterLiteral
  | StringLiteral
  | NullLiteral
IntegerLiteral = DecimalIntegerLiteral
  | HexIntegerLiteral
DecimalIntegerLiteral = DecimalNumeral IntegerTypeSuffix?
HexIntegerLiteral = HexNumeral IntegerTypeSuffix?

DecimalNumeral = '0'
  | NonZeroDigit Digits?
  | NonZeroDigit Underscores Digits
NonZeroDigit = '1-9'
Digits = Digit
  | Digit DigitsAndUnderscores? Digit
Digit = '0-9'
DigitsAndUnderscores = DigitOrUnderscore DigitOrUnderscore*
DigitOrUnderscore = Digit | '_'
Underscores = '_'+

HexNumeral = '0' 'xX' HexDigits
HexDigits = HexDigit | HexDigit HexDigitsAndUnderscores? HexDigit
HexDigit = '0-9a-fA-F'
HexDigitsAndUnderscores = HexDigitOrUnderscore+
HexDigitOrUnderscore = HexDigit | '_'

IntegerTypeSuffix = 'l' | 'L'

FloatingPointLiteral = DecimalFloatingPointLiteral
DecimalFloatingPointLiteral = Digits '.' Digits? ExponentPart? FloatTypeSuffix?
  | '.' Digits ExponentPart? FloatTypeSuffix?
  | Digits ExponentPart FloatTypeSuffix?
  | Digits ExponentPart? FloatTypeSuffix
ExponentPart = 'eE' '+\-' Digits
FloatTypeSuffix = 'fFdD'

CharacterLiteral = '\'' SingleCharacter '\'' | '\'' EscapeSequence '\''
SingleCharacter = .-'\'\\'
EscapeSequence = "\\b" | "\\t" | "\\n" | "\\f" | "\\r" | "\\\"" | "\\'" | "\\\\" | OctalEscape
OctalEscape = '\\' '0-7' | '\\' '0-7' '0-7' | '\\' '0-3' '0-7' '0-7'


StringLiteral = '"' StringCharacter* '"'
StringCharacter = .-'"\\' | EscapeSequence

Separator = <'(){}[];,.@' | "..." | "::">
Operator = <"=" | ">" | "<" | "!" | "~" | "?" | ":" | "->" | "==" | ">=" | "<=" | "!=" | "&&" | "||" | "++" | "--" | "+" | "-" | "*" | "/" | "&" | "|" | "^" | "%" | "<<" | ">>" | ">>>" | "+=" | "-=" | "*=" | "/=" | "&=" | "|=" | "^=" | "%=" | "<<=" | ">>=" | ">>>=">
